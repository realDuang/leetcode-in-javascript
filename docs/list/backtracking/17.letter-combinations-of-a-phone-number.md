# [17] 电话号码的字母组合

> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> 示例 1：
>
> 输入：digits = "23"
>
> 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
>
> 示例 2：
>
> 输入：digits = ""
>
> 输出：[]
>
> 示例 3：
>
> 输入：digits = "2"
>
> 输出：["a","b","c"]
>
> 提示：
>
> 0 <= digits.length <= 4
>
> digits[i] 是范围 ['2', '9'] 的一个数字。

这其实就是一个全排列题的变种，由于不存在最优子问题，我们直接用回溯法来解。

解题时记住回溯三要素：做选择，进行下一层递归，取消选择。

当递归进入到字符串与输入长度相等时，存入结果，结束递归。

```ts
function letterCombinations(digits: string): string[] {
  const map: Record<string, string[]> = {
    '2': ['a', 'b', 'c'],
    '3': ['d', 'e', 'f'],
    '4': ['g', 'h', 'i'],
    '5': ['j', 'k', 'l'],
    '6': ['m', 'n', 'o'],
    '7': ['p', 'q', 'r', 's'],
    '8': ['t', 'u', 'v'],
    '9': ['w', 'x', 'y', 'z']
  };

  if (digits.length === 0) return [];
  const res: string[] = [];
  const chosenArr = digits.split('').map(ch => map[ch]);
  backtrack('', 0);
  return res;

  function backtrack(str: string, index: number) {
    if (index === chosenArr.length) {
      res.push(str);
      return;
    }
    const currArr = chosenArr[index];
    for (let i = 0; i < currArr.length; i++) {
      backtrack(str + chosenArr[index][i], index + 1);
    }
  }
}
```
