# 二叉树遍历算法

二叉树算法是整个算法大厦的基石。二叉树可以拓展为多叉树，而多叉树的遍历正是 BFS 与 DFS 的基础；树的遍历加上环判断，即可升级为图的遍历。学会二叉树遍历，就掌握了所有数据结构的遍历法则。

## 前置知识

### DFS 遍历框架

二叉树 DFS 分为前中后序三种，划分依据只有一条：**在什么时机处理当前节点的数据**。

前序在进入左右子节点之前处理；中序在遍历完左子树、准备遍历右子树之前处理；后序在左右子树都遍历完成后处理。

```ts
function helper(node: TreeNode | null) {
  if (!node) return;
  // 前序位置（进入节点时）
  helper(node.left);
  // 中序位置（左子树处理完，右子树处理前）
  helper(node.right);
  // 后序位置（离开节点时）
}
```

若希望写成一个空间复杂度O(1)的非递归模板，可以直接套下面这个统一框架。和递归一样，只要在对应位置写逻辑即可：

```ts
function traverse(root: TreeNode) {
  const stack: TreeNode[] = [];
  let node: TreeNode = root;

  // 只有后序遍历时需要额外记录上一次访问的节点
  let lastVisited: TreeNode | null = null;

  while (node || stack.length) {
    // 先压栈所有左子树
    while (node) {
      // 前序：如果是前序遍历，在这里处理 node
      // doPre(node);
      stack.push(node);
      node = node.left;
    }

    // 把当前节点拿出来
    const cur = stack.pop();
    // 中序：左子树处理完后，在这里处理 cur
    // doIn(cur);

    // 1. 非后序的场景：直接转向右子树
    // node = cur.right;

    // 2. 后序的场景：右子树未处理过则先处理右子树，当前节点先塞回去
    // 右子树已经在刚才处理过了 (lastVisited) 才处理当前节点
    if (cur.right && lastVisited !== cur.right) {
      stack.push(cur);
      node = cur.right;
    } else {
      // 后序：在这里处理 cur
      // doPost(cur);
      lastVisited = cur;
    }
  }
}
```

只写 `doPre` 就是前序，只写 `doIn` 就是中序，只写 `doPost` 就是后序；三者也可以组合使用。

### 前序、中序、后序的本质区别

理解三种遍历方式的**信息流方向**，是选择正确解法的关键：

| 遍历位置 | 可获取的信息                     | 信息流方向            | 适用场景           |
| -------- | -------------------------------- | --------------------- | ------------------ |
| **前序** | 仅父节点传递下来的参数           | 自顶向下（Top-Down）  | 传递状态、路径记录 |
| **中序** | 左子树已处理完毕                 | 左 → 根 → 右          | BST 有序操作       |
| **后序** | 左右子树的完整结果（通过返回值） | 自底向上（Bottom-Up） | 需要子树信息的计算 |

**核心规律**：前序位置的代码只能从函数参数中获取父节点传递来的数据；而后序位置的代码不仅可以获取参数数据，还可以获取子树通过函数返回值传递回来的数据。

例如在 `[257] 二叉树的所有路径` 中，我们需要把从根到叶的路径通过参数一路往下传递，这就是典型的前序位置（Top-Down）处理。而在 `[110] 平衡二叉树` 中，我们需要先知道左右子树各自的高度，才能判断当前节点是否平衡，这就只能在后序位置（Bottom-Up）完成。

### 两种思维模式

掌握了前中后序的信息流方向后，还需要了解二叉树的两种**底层解题思维**，它们贯穿后续所有题型：

- **遍历思维**：用 `traverse` 函数遍历整棵树，配合外部变量累积结果，不需要返回值。
- **分解问题思维**：用有返回值的递归函数，通过子问题（子树）的答案推导原问题的答案。

这两种思维不是题型分类，而是**编码手段**——同一道题往往两种思维都能解，区别在于哪种写起来更自然。后续每个题型中会标注其更适合的思维模式。

面对一道二叉树题目时，按以下顺序思考：

1. **单独抽出一个节点**，它需要做什么？
2. 它需要在什么**时机**（前序 / 中序 / 后序位置）做？
3. 用**遍历思维**还是**分解问题思维**更自然？

---

## 解题决策树

有了前置知识后，拿到一道二叉树题目，按以下决策树选择解法。前四类是基础遍历的直接应用，后三类是在此基础上的组合与进阶：

```
拿到一道二叉树题目
│
│  ── 基础遍历应用 ──
│
├─ 需要从根向下传递状态/路径？
│   └─ 是 → 前序遍历 .......................... → 见「一」
│
├─ 是 BST 且涉及有序性？
│   └─ 是 → 中序遍历 .......................... → 见「二」
│
├─ 需要先拿到子树的计算结果，再推导当前节点？
│   └─ 是 → 后序遍历 .......................... → 见「三」
│
├─ 涉及逐层处理/层级/最短路径？
│   └─ 是 → BFS 层序遍历 ...................... → 见「四」
│
│  ── 组合与进阶 ──
│
├─ 需要构造一棵树？
│   └─ 是 → 分解问题思维（前序位置建根） ........ → 见「五」
│
├─ 需要序列化/比较子树结构？
│   └─ 是 → 后序遍历 + 序列化 .................. → 见「六」
│
└─ 需要找最近公共祖先？
    └─ 是 → 后序遍历 + 分解问题 ................ → 见「七」
```

---

## 一、前序遍历：自顶向下传递状态

**适用场景**：需要从根节点出发，把状态/路径一路往下传递。

**思维模式**：遍历思维为主——在前序位置做选择，往下递归，到达叶节点时判断或收集结果。

### 1.1 根到叶路径

例如在 `[112] 路径总和` 中，从根节点出发，在前序位置将目标值减去当前节点值并传递给子节点，到达叶节点时判断剩余值是否为 0。

```ts
function traverse(node: TreeNode | null, path: number[], target: number) {
  if (!node) return;

  // 前序位置：做选择
  path.push(node.val);

  // 到达叶节点，判断路径
  if (!node.left && !node.right) {
    if (isValid(path, target)) {
      res.push([...path]);
    }
  }

  traverse(node.left, path, target);
  traverse(node.right, path, target);

  // 离开时撤销选择（回溯）
  path.pop();
}
```

题型参考：

1. `[112] 路径总和`
2. `[113] 路径总和 II`
3. `[257] 二叉树的所有路径`
4. `[129] 求根节点到叶节点数字之和`
5. `[437] 路径总和 III`

### 1.2 结构判断与修改

翻转、展平、判断相同/对称等操作，两种思维都可以使用。

例如 `[226] 翻转二叉树`，每个节点要做的事就是交换左右子节点，放在前序位置（先交换再递归）或后序位置（先递归再组装）都能正确完成。

```ts
// 遍历思维：前序位置直接修改
function invertTree(node: TreeNode | null): TreeNode | null {
  if (!node) return null;
  [node.left, node.right] = [node.right, node.left];
  invertTree(node.left);
  invertTree(node.right);
  return node;
}
```

```ts
// 分解问题思维：后序位置组装
function invertTree(node: TreeNode | null): TreeNode | null {
  if (!node) return null;
  const left = invertTree(node.left);
  const right = invertTree(node.right);
  node.left = right;
  node.right = left;
  return node;
}
```

题型参考：

1. `[226] 翻转二叉树`
2. `[572] 另一棵树的子树`
3. `[100] 相同的树`
4. `[101] 对称二叉树`

## 二、中序遍历：BST 有序操作

**适用场景**：题目涉及 BST，且需要利用其有序性。

**核心原理**：BST 的中序遍历结果是有序的。

例如在 `[230] 二叉搜索树中第K小的元素` 中，只需中序遍历到第 K 个节点即可。更多 BST 的内容见 [二叉搜索树](./3.binary-search-tree.md) 专题。

## 三、后序遍历：自底向上汇总结果

**适用场景**：当前节点的答案需要由左右子树的结果推导。这是二叉树中最常见的模式。

**思维模式**：分解问题思维为主——递归函数有明确返回值，在后序位置利用左右子树的返回值计算当前节点的结果。

### 3.1 属性计算类

求二叉树的某个属性值（深度、节点数、直径等）。共同特征：当前节点的答案可以由左右子树的答案直接推导。

例如在 `[104] 二叉树的最大深度` 中，当前节点的深度 = max(左子树深度, 右子树深度) + 1；在 `[222] 完全二叉树的节点个数` 中，节点数 = 左子树节点数 + 右子树节点数 + 1。

**解题公式**：当前节点的属性 = f(左子树属性, 右子树属性, 当前节点值)

```ts
function property(node: TreeNode | null): number {
  if (!node) return baseCase;

  const left = property(node.left);
  const right = property(node.right);

  // 后序位置：利用左右子树的结果计算当前节点的属性
  return f(left, right, node.val);
}
```

示例 — 最大深度：`f = Math.max(left, right) + 1`，`baseCase = 0`

示例 — 节点总数：`f = left + right + 1`，`baseCase = 0`

示例 — 二叉树直径（需要全局变量辅助）：

```ts
function diameterOfBinaryTree(root: TreeNode | null): number {
  let maxDiameter = 0;

  function depth(node: TreeNode | null): number {
    if (!node) return 0;
    const left = depth(node.left);
    const right = depth(node.right);
    // 后序位置更新全局最大直径
    maxDiameter = Math.max(maxDiameter, left + right);
    return Math.max(left, right) + 1;
  }

  depth(root);
  return maxDiameter;
}
```

题型参考：

1. `[104] 二叉树的最大深度`
2. `[543] 二叉树的直径`
3. `[110] 平衡二叉树`
4. `[222] 完全二叉树的节点个数`

### 3.2 任意路径最值

路径可以从任意节点出发到任意节点时，每个节点返回"经过该节点的单边最大路径和"，在后序位置计算"双边路径和"并更新全局最优。

例如在 `[124] 二叉树中的最大路径和` 中，每个节点需要知道左右子树各自能贡献的最大路径和，这只有在后序位置才能拿到。

```ts
function maxPathSum(root: TreeNode | null): number {
  let maxSum = -Infinity;

  function maxGain(node: TreeNode | null): number {
    if (!node) return 0;
    // 负增益的路径直接丢弃
    const left = Math.max(0, maxGain(node.left));
    const right = Math.max(0, maxGain(node.right));

    // 后序位置：尝试用双边路径更新全局最优
    maxSum = Math.max(maxSum, left + right + node.val);

    // 返回单边最大路径（供父节点使用）
    return Math.max(left, right) + node.val;
  }

  maxGain(root);
  return maxSum;
}
```

题型参考：

1. `[124] 二叉树中的最大路径和`
2. `[543] 二叉树的直径`

## 四、BFS 层序遍历

**适用场景**：涉及逐层处理、层级关系、最短路径。

除 DFS 外，二叉树还可以用 BFS 逐层处理节点。核心数据结构是**队列**：每次从队头取出节点处理，再将其子节点入队。

例如在 `[102] 二叉树的层序遍历` 中，通过在每轮循环开始时记录当前队列长度（即本层节点数），就能精确地将每一层的节点分开处理。

### 代码模板

```ts
function levelOrder(root: TreeNode | null): number[][] {
  if (!root) return [];
  const res: number[][] = [];
  const queue: TreeNode[] = [root];

  while (queue.length > 0) {
    const levelSize = queue.length;
    const level: number[] = [];

    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift()!;
      level.push(node.val);
      node.left && queue.push(node.left);
      node.right && queue.push(node.right);
    }

    res.push(level);
  }
  return res;
}
```

### 变体

代码框架几乎固定，面试中的变化只在于**如何处理每一层的数据**：

| 变体                  | 处理方式                           |
| --------------------- | ---------------------------------- |
| 标准层序遍历（102）   | 每层收集到一个子数组               |
| 锯齿形层序遍历（103） | 奇数层正序，偶数层反转             |
| 右视图（199）         | 每层只取最后一个元素               |
| 每层最大值（515）     | 每层取 max                         |
| 最小深度（111）       | 遇到第一个叶节点即返回当前层数     |
| 填充右侧指针（117）   | 利用层内前后节点关系连接 next 指针 |

BFS 多用于求最小高度、最短路径等场景，通常不需遍历完整棵树即可得出答案。

题型参考：

1. `[102] 二叉树的层序遍历`
2. `[103] 二叉树的锯齿形层序遍历`
3. `[107] 二叉树的层序遍历 II`
4. `[199] 二叉树的右视图`
5. `[515] 在每个树行中找最大值`
6. `[111] 二叉树的最小深度`
7. `[117] 填充每个节点的下一个右侧节点指针 II`

---

## 五、构造类

**适用场景**：从遍历序列或其他条件构造一棵二叉树。

**思维模式**：分解问题思维——构造整棵树 = 确定根节点 + 递归构造左子树 + 递归构造右子树。

例如在 `[654] 最大二叉树` 中，根节点就是数组中的最大值，最大值左侧构成左子树，右侧构成右子树。所有构造类题目都遵循这一模式，差异仅在于"如何确定根节点"和"如何划分左右子树的范围"。

### 代码模板

```ts
function build(
  order1: number[], start1: number, end1: number,
  order2: number[], start2: number, end2: number
): TreeNode | null {
  if (start1 > end1) return null;

  // 1. 确定根节点值（从前序/后序的首/尾元素获取）
  const rootVal = getRootVal(order1, start1, end1);
  const root = new TreeNode(rootVal);

  // 2. 在另一个序列中找到根节点位置，计算左子树大小
  const index = findIndex(order2, rootVal);
  const leftSize = index - start2;

  // 3. 递归构造左右子树
  root.left = build(order1, ..., order2, ...);  // 左子树范围
  root.right = build(order1, ..., order2, ...); // 右子树范围

  return root;
}
```

### 从遍历序列反构造二叉树

理解每种遍历结果的特点，是反构造的关键：

> 前序遍历：根节点一定是其结果的第一个。
> 中序遍历：根节点左边是左子树的中序结果，右边是右子树的中序结果。
> 后序遍历：根节点一定是其结果的最后一个。

通过前序或后序确定根节点值，在中序中找到根节点位置即可划分左右子树，进而得到各序列中左右子树的起止位置。

**三种经典构造的核心差异**：

| 输入组合    | 根节点位置                           | 结果唯一性 |
| ----------- | ------------------------------------ | ---------- |
| 前序 + 中序 | 前序首元素                           | 唯一       |
| 后序 + 中序 | 后序末元素                           | 唯一       |
| 前序 + 后序 | 前序首元素，前序第二个元素定位左子树 | 不唯一     |

前序+后序结果不唯一，因为当节点仅有一棵子树时，无法判断其是左子树还是右子树。

**优化技巧**：使用 HashMap 存储中序遍历的 `value → index` 映射，避免每次递归都线性查找。

题型参考：

1. `[105] 从前序与中序遍历序列构造二叉树`
2. `[106] 从中序与后序遍历序列构造二叉树`
3. `[889] 根据前序和后序遍历构造二叉树`
4. `[654] 最大二叉树`

## 六、序列化与子树比较

**适用场景**：判断两棵树是否相同、是否为子树、寻找重复子树。

**思维模式**：分解问题思维——在后序位置将每棵子树序列化为字符串，用 HashMap 记录出现次数。

要拿到一棵子树的完整字符串表示，必须先拿到左右子树的序列化结果再拼上当前节点——这天然就是后序遍历的操作位置。

```ts
function findDuplicateSubtrees(root: TreeNode | null): TreeNode[] {
  const res: TreeNode[] = [];
  const memo = new Map<string, number>();

  function serialize(node: TreeNode | null): string {
    if (!node) return '#';

    const left = serialize(node.left);
    const right = serialize(node.right);

    // 后序位置：拿到左右子树的序列化结果，组装当前子树
    const subTree = `${left},${right},${node.val}`;

    const count = memo.get(subTree) ?? 0;
    if (count === 1) {
      res.push(node);
    }
    memo.set(subTree, count + 1);

    return subTree;
  }

  serialize(root);
  return res;
}
```

题型参考：

1. `[100] 相同的树`
2. `[572] 另一棵树的子树`
3. `[297] 二叉树的序列化与反序列化`

## 七、最近公共祖先（LCA）

**适用场景**：寻找两个节点的最近公共祖先。

**思维模式**：分解问题思维——在后序位置，一个节点能知道左右子树中是否包含目标节点。

例如在 `[236] 二叉树的最近公共祖先` 中，我们需要知道 p 和 q 是否分别存在于左右子树中——这个信息只有在后序位置才能获得。如果左右子树各自找到了一个目标节点，当前节点就是 LCA。

**经典 LCA 模板**：

```ts
function lowestCommonAncestor(root: TreeNode | null, p: TreeNode, q: TreeNode): TreeNode | null {
  if (!root || root === p || root === q) return root;

  const left = lowestCommonAncestor(root.left, p, q);
  const right = lowestCommonAncestor(root.right, p, q);

  // 后序位置：根据左右子树的结果判断
  if (left && right) return root;
  return left ?? right;
}
```

**LCA 变体**：

| 变体                   | 关键差异             | 处理方式                |
| ---------------------- | -------------------- | ----------------------- |
| 标准 LCA（236）        | p、q 一定存在        | 标准模板                |
| BST 的 LCA（235）      | 利用 BST 有序性      | 比较值大小，走左/右子树 |
| 节点可能不存在（1644） | 需确认两个节点都找到 | 额外 boolean 标记       |
| 有父指针（1650）       | 转化为链表交叉问题   | 等同于相交链表（160）   |

**BST 的 LCA** 可以充分利用有序性优化：

```ts
function lowestCommonAncestor(root: TreeNode | null, p: TreeNode, q: TreeNode): TreeNode | null {
  if (!root) return null;

  if (p.val < root.val && q.val < root.val) {
    return lowestCommonAncestor(root.left, p, q);
  }
  if (p.val > root.val && q.val > root.val) {
    return lowestCommonAncestor(root.right, p, q);
  }
  return root;
}
```

---

## 总结：解题速查表

| 题型                         | 遍历方式   | 思维模式 | 核心操作位置               |
| ---------------------------- | ---------- | -------- | -------------------------- |
| 根到叶路径                   | 前序       | 遍历     | 前序位置做选择，叶节点判断 |
| 结构判断与修改（翻转/对称）  | 前序或后序 | 两种皆可 | 前序直接改 / 后序组装      |
| BST 有序操作                 | 中序       | 遍历     | 中序位置处理有序性         |
| 属性计算（深度/节点数/直径） | 后序       | 分解问题 | 后序位置组合左右结果       |
| 任意路径最值                 | 后序       | 分解问题 | 后序位置更新全局最优       |
| 逐层处理/最短路径            | BFS        | 遍历     | 每层循环处理               |
| 构造二叉树                   | 前序       | 分解问题 | 前序位置创建根节点         |
| 子树比较/序列化              | 后序       | 分解问题 | 后序位置序列化子树         |
| 最近公共祖先                 | 后序       | 分解问题 | 后序位置判断左右结果       |
